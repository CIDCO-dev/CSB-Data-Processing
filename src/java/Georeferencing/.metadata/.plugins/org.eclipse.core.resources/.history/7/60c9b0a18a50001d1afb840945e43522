package ca.cidco.csb.georeference;

import java.awt.LinearGradientPaint;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.Timestamp;
import java.util.ArrayList;

import ca.cidco.csb.utilities.Conversion;
import ca.cidco.csb.utilities.Interpolation;
import ca.cidco.csb.surveydata.Attitude;
import ca.cidco.csb.surveydata.Depth;
import ca.cidco.csb.surveydata.Position;

public class Georeference {

	public static  ArrayList<BathymetryPoint> georeference(ArrayList<Position> positions, ArrayList<Attitude> attitudes, ArrayList<Depth> depths){
		
		ArrayList<BathymetryPoint> bathymetryPoints = new ArrayList<BathymetryPoint>();
				
		int attitudeIndex =0;
		int positionIndex =0;
		
		
		for (Depth depth : depths) {
			// set attitude index to the highest timestamp before depth timestamp 
			while (attitudeIndex+1 < attitudes.size() && attitudes.get(attitudeIndex+1).getTimestamp().before(depth.getTimestamp())) {
				attitudeIndex ++;
			}
			// if end of attitude list
			if(attitudeIndex >= attitudes.size()-1) {
				break;
			}
			// set positionIndex to the highest timestamp before depth timestamp 
			while (positionIndex+1 < positions.size() && positions.get(positionIndex+1).getTimestamp().before(depth.getTimestamp())) {
				positionIndex ++;
			}
			// if end of positions list
			if(positionIndex >= positions.size()-1) {
				break;
			}
			//No position or attitude smaller than depth, so discard this depth
			if (positions.get(positionIndex).getTimestamp().after(depth.getTimestamp()) || attitudes.get(attitudeIndex).getTimestamp().after(depth.getTimestamp())) {
				continue;
			}
			
            Attitude beforeAttitude = attitudes.get(attitudeIndex);
            Attitude afterAttitude = attitudes.get(attitudeIndex+1);

            Position beforePosition = positions.get(positionIndex);
            Position afterPosition = positions.get(positionIndex+1);

            
            Attitude interpolatedAttitude = interpolateAttitude(beforeAttitude, afterAttitude, depth.getTimestamp());
            Position interpolatedPosition = interpolatePosition(beforePosition, afterPosition, depth.getTimestamp());
            
            
            
            
            Position interpolatePosition(Position p1, Position p2, uint64_t timestamp) {
                double interpLat = linearInterpolationByTime (p1.getLatitude(), p2.getLatitude(), timestamp, p1.getTimestamp(), p2.getTimestamp());
                double interpLon = linearInterpolationByTime(p1.getLongitude(), p2.getLongitude(), timestamp, p1.getTimestamp(), p2.getTimestamp());
                double interpAlt = linearInterpolationByTime(p1.getEllipsoidalHeight(), p2.getEllipsoidalHeight(), timestamp, p1.getTimestamp(), p2.getTimestamp());
                return new Position(timestamp,interpLat, interpLon, interpAlt);
              }
//
//              /**
//              * Returns an interpolated attitude between two attitude(attitude)
//              *
//              * @param a1 first attitude
//              * @param a2 second attitude
//              * @param timestamp time in microsecond since 1st January 1970
//              */
//              static Attitude* interpolateAttitude(Attitude & a1, Attitude & a2,uint64_t timestamp) {
//                double interpRoll = linearAngleInterpolationByTime(a1.getRoll(), a2.getRoll(), timestamp, a1.getTimestamp(), a2.getTimestamp());
//                double interpPitch = linearAngleInterpolationByTime(a1.getPitch(), a2.getPitch(), timestamp, a1.getTimestamp(), a2.getTimestamp());
//                double interpHeading = linearAngleInterpolationByTime(a1.getHeading(), a2.getHeading(), timestamp, a1.getTimestamp(), a2.getTimestamp());
//                return new Attitude(timestamp,interpRoll, interpPitch, interpHeading);
			
			
		}
		
	}
		
		
	
	    /**
	     * The interpolation algorithm.
	     *
	     * @param y1 composante y du premier point
	     * @param y2 composante y du second point
	     * @param x position en x à interpoler
	     * @param x1 composante x du premier point
	     * @param x2 composante y du second point
	     * @return composante y interpolée
	     */
	
	
//	public static BigDecimal linearInterpolation(BigDecimal y1, BigDecimal y2, BigDecimal x, BigDecimal x1, BigDecimal x2) {
//		BigDecimal deltaTime = BigDecimalFactory.create((double) (x.doubleValue() - x1.doubleValue()) / (double) (x2.doubleValue() - x1.doubleValue()));
//		BigDecimal newValue = (y1.add(y2.subtract(y1).multiply(deltaTime))).setScale(20, RoundingMode.HALF_UP);
//		return newValue;
//	}
}
