package ca.cidco.csb.utilities;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.Timestamp;

import ca.cidco.csb.surveydata.Attitude;

public class Interpolation {

	
    /**
     * The interpolation algorithm.
     *
     * @param y1 composante y du premier point
     * @param y2 composante y du second point
     * @param x position en x à interpoler
     * @param x1 composante x du premier point
     * @param x2 composante x du second point
     * @return composante y interpolée
     */
	
    public static BigDecimal linearInterpolation(BigDecimal y1, BigDecimal y2, BigDecimal x, BigDecimal x1, BigDecimal x2) {
        BigDecimal deltaTime = BigDecimalFactory.create((double) (x.doubleValue() - x1.doubleValue()) / (double) (x2.doubleValue() - x1.doubleValue()));
        BigDecimal newValue = (y1.add(y2.subtract(y1).multiply(deltaTime))).setScale(20, RoundingMode.HALF_UP);
        return newValue;
    }
    
    

  /**
  * Returns an interpolated attitude between two attitude(attitude)
  *
  * @param a1 first attitude
  * @param a2 second attitude
  * @param timestamp time in microsecond since 1st January 1970
  */
    public static Attitude interpolateAttitude(Attitude a1, Attitude a2,Timestamp timestamp) {
	    double interpRoll = linearAngleInterpolationByTime(a1.getRoll(), a2.getRoll(), timestamp.getTime(), a1.getTimestamp(), a2.getTimestamp());
	    double interpPitch = linearAngleInterpolationByTime(a1.getPitch(), a2.getPitch(), timestamp.getTime(), a1.getTimestamp(), a2.getTimestamp());
	    double interpHeading = linearAngleInterpolationByTime(a1.getHeading(), a2.getHeading(), timestamp.getTime(), a1.getTimestamp(), a2.getTimestamp());
	    return new Attitude(timestamp,interpRoll, interpPitch, interpHeading);

    }
    
    /**
     * Returns a linear interpolation between two meter
     *
     * @param y1 first meter
     * @param y2 second meter
     * @param x number of microsecond since 1st January 1970
     * @param x1 timestamp link y1
     * @param x2 timestamp link to y2
     * @throws Exception 
     */
     static double linearInterpolationByTime(double y1, double y2, Timestamp timestamp, Timestamp t1, Timestamp t2) throws Exception {
    	 long x= timestamp.getTime();
    	 long x1= t1.getTime();
    	 long x2= t2.getTime();
    	 
         if (x1 == x2) {
        	 throw new Exception("The two positions timestamp are the same");
         }
         if (x1 > x) {
        	 throw new Exception("The first position timestamp is higher than interpolation timestamp");
         }
         if (x1 > x2) {
             throw new Exception("The first position timestamp is higher than the second position timestamp");
         }
       double result = (y1 + (y2 - y1)*(x - x1) / (x2 - x1));
       return result;
     }
     
     
     

     /**
     * Returns a linear interpolation between two angle
     *
     * @param psi1 first angle
     * @param psi2 second angle
     * @param t number of microsecond since 1st January 1970
     * @param t1 timestamp link to psi1
     * @param t2 timestamp link to psi2
     * @throws Exception 
     */
     
     static double linearAngleInterpolationByTime(double psi1, double psi2, Timestamp t, Timestamp t1, Timestamp t2) throws Exception {

    	 long x= t.getTime();
    	 long x1= t1.getTime();
    	 long x2= t2.getTime();
    	 
	    if (t1 == t2)
	      {
	          throw new Exception("The two positions timestamp are the same");
	      }
	      if (t1 > t)
	      {
	          throw new Exception("The first position timestamp is higher than interpolation timestamp");
	      }
	      if (t1 > t2)
	      {
	          throw new Exception("The first position timestamp is higher than the second position timestamp");
	      }
	
	    if ( Math.abs(psi2 - psi1)==180){
	        throw new Exception("The angles " + psi1 + " and " + psi2 + " have a difference of 180 degrees which means there are two possible answers at timestamp " + t);
	    }
	
	    if (psi1 == psi2) {
	      return psi1;
	    }
	
	    double x1 = t-t1;
	    double x2 = t2-t1;
	    double delta = (x1 / x2);
	    double dpsi = Math.IEEEremainder((Math.IEEEremainder(psi2 - psi1, 360) + 540), 360) - 180;
	
	    double total = psi1 + dpsi*delta;
	
	    if(total > 0){
	    	return (total < 360.0)? total : Math.IEEEremainder(total,360.0);
	    }
	    else{
	    	return total + 360.0; //TODO: handle angles -360....-520...etc
	    }
	  }


}
